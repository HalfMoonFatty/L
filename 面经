implement hash table, consider key collision, hash function, concurrency, reader-writer, etc.

bounded blocking queue
http://n00tc0d3r.blogspot.com/2013/08/implement-bounded-blocking-queue.html


Design problems:
1. inverted index partitioning
1st question, how to implement must queries efficiently (e.g. find documents that must have "foo" and have "bar")
2nd question, if there are huge number of documents and huge number of terms, how do you partition, and how to implement query

2. implement a key-value store
you have limited memory: enough to store all the keys in memory (and plus some metadata information for each key in memory) 
but values can potentially be very large and cannot fit in memory; you have a file system, you can create files, delete files, 
read from files, write to files, for writes you can only append to end of file, you cannot modify contents in the middle of a file 
or insert contents in the middle of a file.
consider concurrency, efficiency, garbage collection, etc.


one more design problem:
design a statistics collection and reporting system for data-center machines (large number of machines that report large number of stats, 
long history data, etc), you can read about LinkedIn's inGraph to get some ideas (inGraph sucks in some ways, not necessarily all its design decisions are perfect):
https://engineering.linkedin.com/metrics/scaling-collection-self-service-metrics
https://engineering.linkedin.com/32/eric-intern-origin-ingraphs
